Advanced Usage Guide
####################

Introduction
************

The :ref:`QSGuideLabel` provides a recommended basic usage for
the Ill Conditioning Explainer.   However, in a significant number
of instances, large explanations that are difficult to interpret
remain after executing the recommended workflow.   This section will
discuss how to effectively interpret the explainer output, including
for larger explanations.  In addition it will describe  additional
arguments to the explainer functions that can reduce the size of the
explanations.

Interpreting the Explainer Output
*********************************

The :ref:`QSGuideLabel` describes how to interpret the meaning of
the rows or columns in the LP or MPS file generated by the explainer.
However, extracting the specific cause of the ill conditioning from
these files can be more challenging.   This section provides some guidance
on how to do so.   Specifically, by making full use of the linear combination
vector values and watching for common model structures that can cause
ill conditioned basis matrices, even large explanations can often be
used to effectively identify the source of the ill conditioning.  

Regarding making full use of the linear combination vector values, recall
from the :ref:`QSIntroductionLabel` section that the vector satisfies
the condition :math:`||B^{T}y||_{\infty} \leq \epsilon` and
:math:`||y|| >> \epsilon`.  The explainer output lists the rows or
columns ordered by largest absolute multiplier value.   Small multiplier
values can be ignored from consideration as long as the corresponding
basis matrix row or column values are orders of magnitude larger than 1.0.
In such cases, their contribution to the inner product :math:`B^{T}y`
is negligible.  But if the row or column values are significantly larger,
they still contribute significantly to the ill conditioning.

Regarding common model structures in ill conditioned models, three in
particular have occurred both in the more than 15 years of Gurobi customer
tickets and in the recent development of the Ill Conditioning Explainer.
Searching for small subset of constraints or variables in a large
explanation can often identify the source of ill conditioning without
having to look at most of its contents.

* **Mixtures of large and small coefficients in matrix rows or columns.**
  The definition of the condition number of a square matrix B is
  :math:`||B||*||B^{-1}||`. Large ratios in B can easily result in large
  values in either :math:`||B||` or :math:`||B^{-1}||`.   In many cases
  such large ratios are unnecessary and can be avoided.   For example,
  using more suitable units of measurements (e.g., counting in thousands
  of dollars rather than dollars) or reducing unnecessarily large values
  in big M constraints used to model fixed charges can often improve the large
  ratios without affecting the meaning of the model.  

* **Imprecise rounding of matrix coefficient values.**
  Rounded repeating decimals associated with fractions can turn truly
  parallel rows, which do not create issues with ill conditioning, into
  nearly parallel rows, which do.  For models with fractional data
  with repeating decimal places, avoid imprecise rounding
  of these values, e.g.,  don't calculate 1/3 or 5/7 to 10 decimal places 
  instead of the full 16 decimal places that are available in the 64 bit
  doubles that Gurobi uses to input the problem data.  Better yet, if the
  numerator and denominator of the fractions in a constraint are known
  when building the model, use the denominators to rescale the matrix row
  to have all integer data.   For example, the constraint 1/3 x + 5/7 y <= 10
  can be multiplied 21 (the product of the denominators) to yield the all
  integer constraint 7x + 15y <= 210, which will yield a more precise
  representation of the coefficients.   Similarly, watch for matrix
  coefficients that are supposed to respresent the same value but have
  different levels of precision in different places.   This happens
  surprisingly often, either because different parts of the model are
  created over time, or because values are calculated in mathematically
  equivalent ways that have slight differences when calculated under
  finite precision.  For example, note the difference in the 16th
  decimal place of the following two mathematically equivalent values
  when calculated with Python::
    
    >>> import math
    >>> math.sqrt(2)/2
    0.7071067811865476
    >>> math.sin(math.radians(45))
    0.7071067811865475
    >>>
    
  Such slight differences can turn identical coefficients into slightly
  different ones, which in turn can transform truly parallel rows into
  almost parallel ones, thus creating ill conditioning.  If the values
  are mathematically equivalent, they should be same to the lowest order
  bit in the LP or MIP, and care should be taken to ensure they are
  computed in the same way in the model generation process.

* **Long Sequences of Transfer Constraints.**
  Transfer constraints multiply a variable by a number and assign
  the expression into a new variable.   A long sequence of such
  constraints where each variable appears as output in one constraint
  and input in the next can implicitly create a large numeric value and
  a basis matrix with a high condition number.   For example, consider

  .. math::

     x_1 = 2x_2 \\
     x_2 = 2x_3 \\
     x_3 = 2x_4 \\
     \vdots     \\
     x_{n-1} = 2x_n  \\
     x_j \geq 0, j=1,\cdots, n

  These constraint have coefficients have neither imprecise rounding nor
  large ratios of coefficients, yet this structure can lead to an ill
  conditioned basis matrix.  These constraints define a long sequence of
  transfers of variable activity levels, starting with :math:`x_n` and
  ending with :math:`x_1`.   Hence they imply the constraint
  :math:`x_1=2^nx_n`, which does have a large coefficient ratio.
  Also, note that if any one of the variables :math:`x_j` in the sequence
  of transfer constraints is positive, all of them will be, and they
  all will be basic.  The associated square submatrix of the LP has the form

  .. image:: _static/Basis.png
      :align: center
      :scale: 60 %

  
  This submatrix has inverse of the form

  .. image:: _static/BasisInv.png
      :align: center
      :scale: 60 %

Given that the condition number of a square matrix B is
:math:`||B||*||B^{-1}||`, one can see that the submatrix of transfer
constraints contributes :math:`2^n` to the overall basis condition
number.  Hence it can be a source of ill conditioning for even modest
values of n.

Here is some sample ill conditioning explainer output of a long
sequence of transfer constraints from a run on a subproblem of
a publicly available model where the basis condition number was in
the order of :math:`10^{31}`.  Note that each variable appears in
consecutive constraints, and that the coefficients in each constraint
are the same.  In this model the variables are free variables rather han
being bounded below by 0. 

| (mult=1.267949192397407)e11923: 0.221528652 x33590 = 0
| (mult=-0.3397459621039425)e11803: 0.221528652 x32870 + 0.8267561847 x33590 = 0
| (mult=0.09103465616606164)e11683: 0.221528652 x32150 + 0.8267561847 x32870 = 0
| (mult=-0.02439266259987994)e11563: 0.221528652 x31430 + 0.8267561847 x32150 = 0
| (mult=0.006535994244062434)e11443: 0.221528652 x30710 + 0.8267561847 x31430 = 0
| (mult=-0.0017513143792112112)e11323: 0.221528652 x29990 + 0.8267561847 x30710 = 0
| (mult=0.00046926327354376596)e11203: 0.221528652 x29270 + 0.8267561847 x29990 = 0
| (mult=-0.00012573871516785733)e11083: 0.221528652 x28550 + 0.8267561847 x29270 = 0
| (mult=3.3691587182326145e-05)e10963: 0.221528652 x27830 + 0.8267561847 x28550 = 0
| (mult=-9.027633576094116e-06)e10843: 0.221528652 x27110 + 0.8267561847 x27830 = 0
| (mult=2.4189471259749366e-06)e10723: 0.221528652 x26390 + 0.8267561847 x27110 = 0
| (mult=-6.481549288572281e-07)e10603: 0.221528652 x25670 + 0.8267561847 x26390 = 0
| (mult=1.736725897357507e-07)e10483: 0.221528652 x24950 + 0.8267561847 x25670 = 0
| (mult=-4.6535430161276043e-08)e10363: 0.221528652 x24230 + 0.8267561847 x24950 = 0
| (mult=1.246913092958399e-08)e10243: 0.221528652 x23510 + 0.8267561847 x24230 = 0
| (mult=-3.341093562480668e-09)e10123: 0.221528652 x22790 + 0.8267561847 x23510 = 0
| (mult=8.952433217911677e-10)e10003: 0.221528652 x22070 + 0.8267561847 x22790 = 0
| (mult=-2.3987972507319496e-10)e9883: 0.221528652 x21350 + 0.8267561847 x22070 = 0
| (mult=6.427557860589595e-11)e9763: 0.221528652 x20630 + 0.8267561847 x21350 = 0
| (mult=-1.7222589378332707e-11)e9643: 0.221528652 x19910 + 0.8267561847 x20630 = 0
| (mult=4.614778914917941e-12)e9523: 0.221528652 x19190 + 0.8267561847 x19910 = 0
| (mult=-1.2365262833452548e-12)e9403: 0.221528652 x18470 + 0.8267561847 x19190 = 0
| (mult=3.3132621900063825e-13)e9283: 0.221528652 x17750 + 0.8267561847 x18470 = 0

Finally, note that the ratio of the multipliers for consecutive constraints
remains constant from start to finish, and is in fact the ratio of the two
coefficients :math:`0.8267561847/0.221528652`.

Remedies for long sequences of transfer constraints are not as simple
as for imprecise rounding or large ratios of coefficients in the basis
matrix rows or columns.   The model developer should assess the meaning of
these constraints in the context of the whole model, and why the activities
at the start of the sequence are implicitly being rescaled to much larger
values at the end of the sequence.
    
For a more detailed discussion of common sources of ill conditioning
in LPs and MILPs, see Section 4 of 
https://pubsonline.informs.org/doi/10.1287/educ.2014.0130.

Additional Function Arguments
*****************************

The :ref:`QSGuideLabel` describes the most common usage of the explainer
functions <LINK> kappa_explain and <LINK>angle_explain.   This section
considers additional function arguments that can help reduce the size of
the explanation, potentially making it easier to interpret.  A complete
list of function arguments appears in the <LINK> API section.


The kappa_explain() method
--------------------------

The <LINK> kappa_explain method provides a row or column based explanation
of the cause of ill conditioning in a basis matrix.  It has several arguments
designed to reduce the size of the explanation.

* **The expltype parameter** instructs the explainer to provide a row or
  column based explanation.   As discussed in the :ref:`QSGuideLabel`,
  one of these two explanations may be smaller and easier to interpret
  than the other.   Set this parameter to "ROWS" or "COLS" for a row or
  column based explanation respectively.  In general if the first explanation
  you try among these two seems too large or difficult to interpret, try
  the other one.

* **The smalltol parameter**
  specifies the tolerance used with the certificate of infeasibility
  to filter out rows or columns of the basis matrix in the explanation.
  Recall from the :ref:`QSIntroductionLabel` section that the certificate
  of infeasibility vector y satisfies
  :math:`||B^{T}y||_{\infty} \leq \epsilon` and :math:`||y|| >> \epsilon`.
  Elements of y that are zero identify basis matrix rows or columns that
  can be removed from the explanation.   However, in numerous explanations,
  rows or columns with small multipliers contribute little insight to the
  explanation and can be ignored.  The smalltol parameter is optional,
  and by default the explainer will use a base value of :math:`10^{13}`,
  but also consider each row or column norm as well as the machine precision.
  Specifying a non default value other than :math:`10^{13}` replaces the
  default setting with the alternate value to be used in the row or column
  filtering process.  Note that the explainer output file lists the rows or
  columns ordered in descending order starting with the absolute multiplier
  value, so one can visually filter the small multipliers as well.   Keep in
  mind that equal multipliers does not imply equal contribution to the
  ill conditioning.  A small multiplier associated with a row or column with
  all (absolute) coefficient values at most 1 contributes significantly less
  then the same multiplier associated with a row or column with coefficient
  values on the order of :math:`10^{8}`

* **The method parameter** enables alternate formulations of the internal model
  that computes the certificate of ill conditioning.  These options currently
  involve regularization methods of the objective that try to reduce the size
  of the explanation.   The default setting performs no regularization.
  The "ANGLES" option invokes the <section LINK> angle_explain() method,
  which will be discussed subsequently.   When invoked from kappa_explain
  with method="ANGLES", a single pair of almost parallel rows or columns
  will be returned, if it exists.  Setting method="LASSO" invokes the
  Lasso method, which involves adding a regularization term to the objective
  consisting of the sum of absolute values of the certificate variables.
  Setting method="RLS" uses regularized least squares instead, which instead
  uses the sum of squares of the certificate variables.

* **The submatrix parameter** performs postprocessing of the computed
  explanation to try to reduce the size.   The default setting is False;
  set it to True to enable this feature.  Initial tests with this parameter
  show reductions in explanation size of 20-50 percent.   Unfortunately,
  however, this level of reduction has been of limited value on large
  explanations of hundreds or thousands of rows or columns, as the explanation
  remains quite large after this postprocessing is performed.


The angle_explain() method
---------------------------

The <LINK> angle_explain method looks for near parallel pairs of basis matrix
rows or columns.  It does not solve a subproblem.   The explanations it finds,
if any exist, are always easy to interpret.   But for many ill conditioned
basis matrices no near parallel pairs exist, and the routine provides no
information (other than the fact that any explanation has at least 3 rows
or columns).  It is simpler to use, and the only required argument is the
LP model.   Two other parameters provide some additional control.

* **The howmany parameter** specifies the number of near parallel rows and
  columns to search for.   If not specified, this defaults to 1.  Specify a
  positive integer for a particular number of pairs.   Specify an integer
  <= 0 to request all pairs.   The routine searches the rows first, then the
  columns.   Requesting more pairs can increase the run time of the routine.

* **The partol parameter**  specifies the tolerance below which two row os
  column vectors are considered almost parallel.  It defaults to
  :math:`10^{-6}`.  It is used as a relative tolerance when comparing the
  inner product of two vectors with the product of their L1 norms.
